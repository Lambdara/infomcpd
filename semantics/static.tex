\documentclass[11pt]{article}
\usepackage[a4paper,margin=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{cleveref}
\usepackage{float}

\newcommand\SED{\emph{sed}}
\newcommand\RULE[3][]{\begin{array}{c} #2 \\ \hline #3 \end{array}}
\newcommand\data[1]{\ensuremath{\text{#1}}}
\newcommand\field[1]{\ensuremath{\text{#1}}}
\newcommand\J[1]{\ensuremath{\textbf{#1}}}
\newcommand\cmd[1]{\ensuremath{\text{\texttt{#1}}}}
\newcommand\code[1]{\ensuremath{\text{\texttt{#1}}}}
\renewcommand\arg[1]{\ensuremath{\mathit{#1}}}
\newcommand\angles[1]{\langle #1 \rangle}

% Swap \epsilon and \varepsilon
\let\oldepsilon\epsilon \let\epsilon\varepsilon \let\varepsilon\oldepsilon
% Swap \emptyset and \varnothing
\let\oldemptyset\emptyset \let\emptyset\varnothing \let\varnothing\oldemptyset

\begin{document}

\section{Static semantics}

We say a \SED{} program is correct according to the static semantics if the `ok' judgement can be proven of it.
This is true if it is both \textbf{l}abel-\textbf{c}orrect and \textbf{y}-\textbf{c}orrect:
\begin{gather*}
	\RULE{s\ \J{sed} \qquad s\ \J{lc} \qquad s\ \J{yc}}{s\ \J{ok}}
\end{gather*}
%
A program is label-correct if it refers only to labels defined elsewhere in the program.
\begin{gather*}
	\RULE{s\ \J{labels}\ L \qquad L \vdash s\ \J{lc'}}{s\ \J{lc}}
\end{gather*}
%
This we do by first collecting all the labels (and verifying that they are unique):
\begin{gather*}
	\RULE{}{\epsilon\ \J{labels}\ \emptyset} \qquad
	\RULE{s\ \J{labels}\ L \qquad \ell \not\in L}{((\cmd{:}\ \ell)\ s)\ \J{labels}\ \{\ell\} \cup L} \\
%
	\RULE{(s_1\ s)\ \J{labels}\ L}{(\cmd{\{} s_1 \cmd{\}}\ s)\ \J{labels}\ L} \qquad
	\RULE{(\arg{fun}\ s)\ \J{labels}\ L}{(\angles{\ldots, \arg{fun}}\ s)\ \J{labels}\ L} \qquad
	\RULE{s\ \J{labels}\ L}{(\text{\underline{anything else}}\ s)\ \J{labels}\ L}
\end{gather*}
The ``$\angles{\ldots, \arg{fun}}$'' should be understood to match any command with an address of any form (1- or 2-part, and negated or not negated) and function \arg{fun}.
The ``\underline{anything else}'' should be understood to match anything that is not a label, a block or a command with an address.

Then, we verify that all label-referencing instructions only refer to labels that we have collected:
\begin{gather*}
	\RULE{}{L \vdash \epsilon\ \J{lc'}} \qquad
	\RULE{\ell \in L \qquad L \vdash s\ \J{lc'}}{L \vdash (\cmd{b}\ \ell)\ s\ \J{lc'}} \qquad
	\RULE{\ell \in L \qquad L \vdash s\ \J{lc'}}{L \vdash (\cmd{t}\ \ell)\ s\ \J{lc'}} \\
%
	\RULE{L \vdash s_1\ \J{lc'} \qquad L \vdash s\ \J{lc'}}{L \vdash \cmd{\{} s_1 \cmd{\}}\ s\ \J{lc'}} \qquad
	\RULE{L \vdash \arg{fun}\ s\ \J{lc'}}{L \vdash \angles{\ldots, \arg{fun}}\ s\ \J{lc'}} \qquad
	\RULE{L \vdash s\ \J{lc'}}{L \vdash \text{\underline{anything else}}\ s\ \J{lc'}}
\end{gather*}
The ``\underline{anything else}'' should be understood to match anything that is not a \cmd{b} or \cmd{t} command, a block, or a command with an address.

A program is y-correct if for each \cmd{y}-instruction in the program, the pattern and replacement have equal length and the pattern does not contain duplicate characters:
\begin{gather*}
	\RULE{}{\epsilon\ \J{yc}} \qquad
	\RULE{|\arg{pat}| = |\arg{repl}| \qquad \arg{pat}\ \J{nodup} \qquad s\ \J{yc}}{((\cmd{y}\ \arg{pat}\ \arg{repl})\ s)\ \J{yc}} \\
%
	\RULE{s_1\ \J{yc} \qquad s\ \J{yc}}{(\cmd{\{} s_1 \cmd{\}}\ s)\ \J{yc}} \qquad
	\RULE{(\arg{fun}\ s)\ \J{yc}}{(\angles{\ldots, \arg{fun}}\ s)\ \J{yc}} \\
	\RULE{}{\epsilon\ \J{nodup}} \qquad
	\RULE{(c\ s)\ \J{str} \qquad c\ \J{notin}\ s \qquad s\ \J{nodup}}{(c\ s)\ \J{nodup}} \\
	\RULE{c\ \J{char}}{c\ \J{notin}\ \epsilon} \qquad
	\RULE{c\ \J{char} \qquad (c'\ s)\ \J{str} \qquad c \not= c' \qquad c\ \J{notin}\ s}{c\ \J{notin}\ (c'\ s)}
\end{gather*}


\end{document}

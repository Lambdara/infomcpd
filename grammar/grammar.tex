\documentclass[11pt]{article}
\usepackage[a4paper,margin=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{cleveref}
\usepackage{float}
\usepackage{xifthen}

\newcommand{\ifempty}[3]{\ifthenelse{\isempty{#1}}{#2}{#3}}

\newcommand\SED{\emph{sed}}
\newcommand\RULE[3][]{\begin{array}{c} #2 \\ \hline #3 \end{array}\ifempty{#1}{}{\namef{\text{\ \ #1}}}}
\newcommand\data[1]{\ensuremath{\text{#1}}}
\newcommand\field[1]{\ensuremath{\text{#1}}}
\newcommand\J[1]{\ensuremath{\textbf{#1}}}
\newcommand\cmd[1]{\ensuremath{\text{\texttt{#1}}}}
\newcommand\code[1]{\ensuremath{\text{\texttt{#1}}}}
\renewcommand\arg[1]{\ensuremath{\mathit{#1}}}
\newcommand\angles[1]{\langle #1 \rangle}

% Swap \epsilon and \varepsilon
\let\oldepsilon\epsilon \let\epsilon\varepsilon \let\varepsilon\oldepsilon

\begin{document}

\section{Program representation}

We specify what programs are valid \SED{} programs by giving a description of the set of valid programs using inference rules.
This is done using the rules below, where the ``sed'' judgement indicates being a member of this set.
Note that these rules do not yet define the static semantics, only an abstract representation of \SED{} programs that the semantics operate on.
Note also that the programs defined by this rule set form a strict subset of the programs specified by the official \SED{} specification\footnote{\url{https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html}}, since the \texttt{l}, \texttt{r}, \texttt{w} and \texttt{\#} commands are missing, as well as an \texttt{s} flag.


A program consists of commands, which consist of an address and a function.
Functions can take a varying number of addresses, though a function can always take less addresses than specified.
\begin{gather*}
	\RULE{}{\epsilon\ \J{sed}} \qquad
	\RULE{c\ \J{cmd} \qquad s\ \J{sed}}{c\ s\ \J{sed}} \\
	\RULE{\arg{f}\ \J{fun}}{\angles{\epsilon, f}\ \J{cmd}} \qquad
	\RULE{a\ \J{addr1} \qquad f\ \J{fun1}}{\angles{a, f}\ \J{cmd}} \qquad
	\RULE{a\ \J{addr1} \qquad f\ \J{fun2}}{\angles{a, f}\ \J{cmd}} \qquad
	\RULE{a\ \J{addr2} \qquad f\ \J{fun2}}{\angles{a, f}\ \J{cmd}} \\
	\RULE{\arg{f}\ \J{fun0}}{\arg{f}\ \J{fun}} \qquad
	\RULE{\arg{f}\ \J{fun1}}{\arg{f}\ \J{fun}} \qquad
	\RULE{\arg{f}\ \J{fun2}}{\arg{f}\ \J{fun}}
\end{gather*}
Commands can be nested in blocks:
\begin{gather*}
	\RULE{\arg{cmds}\ \J{sed}}{\cmd{\{} \arg{cmds} \cmd{\}}\ \J{fun2}}
\end{gather*}
Functions that (optionally) take a label:
\begin{gather*}
	\RULE{\arg{label}\ \J{label}}{\cmd{:}\ \arg{label}\ \J{fun0}} \qquad
	\RULE{\arg{label}\ \J{label}}{\cmd{b}\ \arg{label}\ \J{fun2}} \qquad
	\RULE{}{\cmd{b}\ \J{fun2}} \qquad
	\RULE{\arg{label}\ \J{label}}{\cmd{t}\ \arg{label}\ \J{fun2}} \qquad
	\RULE{}{\cmd{t}\ \J{fun2}}
\end{gather*}
Simple functions that take no arguments: (Note that \cmd{q} and \cmd{=} are 1-address functions.)
\begin{gather*}
	\RULE{}{\cmd{d}\ \J{fun2}} \qquad
	\RULE{}{\cmd{D}\ \J{fun2}} \qquad
	\RULE{}{\cmd{g}\ \J{fun2}} \qquad
	\RULE{}{\cmd{G}\ \J{fun2}} \qquad
	\RULE{}{\cmd{h}\ \J{fun2}} \qquad
	\RULE{}{\cmd{H}\ \J{fun2}} \\
	\RULE{}{\cmd{n}\ \J{fun2}} \qquad
	\RULE{}{\cmd{N}\ \J{fun2}} \qquad
	\RULE{}{\cmd{p}\ \J{fun2}} \qquad
	\RULE{}{\cmd{P}\ \J{fun2}} \qquad
	\RULE{}{\cmd{q}\ \J{fun1}} \qquad
	\RULE{}{\cmd{x}\ \J{fun2}} \qquad
	\RULE{}{\cmd{=}\ \J{fun1}}
\end{gather*}
Some commands take a text argument:
\begin{gather*}
	\RULE{\arg{text}\ \J{str}}{\cmd{a}\ \arg{text}\ \J{fun1}} \qquad
	\RULE{\arg{text}\ \J{str}}{\cmd{i}\ \arg{text}\ \J{fun1}} \qquad
	\RULE{\arg{text}\ \J{str}}{\cmd{c}\ \arg{text}\ \J{fun2}}
\end{gather*}
Finally, the substitution commands:
\begin{gather*}
	\RULE{\arg{pat}\ \J{regex} \qquad \arg{repl}\ \J{str} \qquad \arg{flags}\ \J{sflags}}{\cmd{s}\ \arg{pat}\ \arg{repl}\ \arg{sflags}\ \J{fun2}} \qquad
	\RULE{\arg{pat}\ \J{str} \qquad \arg{repl}\ \J{str}}{\cmd{y}\ \arg{pat}\ \arg{repl}\ \J{fun2}}
\end{gather*}
Addresses are specified as follows:
\begin{gather*}
	\RULE{}{\epsilon\ \J{addr}} \qquad
	\RULE{\arg{addr}\ \J{addr1}}{\arg{addr}\ \J{addr}} \qquad
	\RULE{\arg{addr}\ \J{addr2}}{\arg{addr}\ \J{addr}} \\
	\RULE{\arg{addr}\ \J{basead} \qquad \arg{neg}\ \J{adneg}}{\arg{addr}\ \arg{neg}\ \J{addr1}} \qquad
	\RULE{}{\epsilon\ \J{addr1}} \\
	\RULE{a_1\ \J{basead} \qquad a_2\ \J{basead} \qquad \arg{neg}\ \J{adneg}}{a_1,a_2\ \arg{neg}\ \J{addr2}} \qquad
	\RULE{\arg{addr}\ \J{addr1}}{\arg{addr}\ \J{addr2}} \\
	\RULE{n \in \mathbb{Z}_{\geq 1}}{n\ \J{basead}} \qquad
	\RULE{}{\cmd{\$}\ \J{basead}} \qquad
	\RULE{\arg{reg}\ \J{regex}}{\arg{reg}\ \J{basead}} \qquad
	\RULE{}{\epsilon\ \J{adneg}} \qquad
	\RULE{}{\cmd{!}\ \J{adneg}}
\end{gather*}
Where the following auxiliary judgements are used:
\begin{gather*}
	\RULE{}{\epsilon\ \J{str}} \qquad
	\RULE{c\ \J{char} \qquad s\ \J{str}}{c\ s\ \J{str}} \qquad
	\RULE{n \in \mathbb{Z} \qquad 0 \leq n \leq 255}{n\ \J{char}} \\
	\RULE{}{\cmd{g}\ \J{sflag}} \qquad
	\RULE{}{\cmd{p}\ \J{sflag}} \qquad
	\RULE{n \in \mathbb{Z}_{\geq 1}}{n\ \J{sflag}} \qquad
	\RULE{}{\epsilon\ \J{sflags}} \qquad
	\RULE{f\ \J{sflag} \qquad r\ \J{sflags}}{f\ r\ \J{sflags}}
\end{gather*}
The ``label'' judgement defines a set of values on which only an equivalence relation (equality) is required.
The ``regex'' judgement defines the set of accepted regular expressions, which for now is kept abstract.


\end{document}
